# C Standard Library `<complex.h>` Reference

## Overview

The `<complex.h>` header, introduced with the C99 standard, provides macros, types, and functions for complex number arithmetic in C. It supports operations on single, double, and extended precision complex numbers and enables complex mathematical calculations with a wide range of built-in functions.

---

## Macros

| Macro        | Expands To              | Purpose/Usage |
|--------------|-------------------------|--------------|
| `complex`    | `_Complex`              | Alias for `_Complex` type |
| `imaginary`  | `_Imaginary`            | Alias for `_Imaginary` type (rare support) |
| `_Complex_I` | `const float _Complex`  | Imaginary unit constant; value for i where i² = -1 |
| `_Imaginary_I` | `const float _Imaginary` | Pure imaginary unit (rare support) |
| `I`          | `_Imaginary_I` or `_Complex_I` | Universal macro for the imaginary unit |
| `CMPLX(x, y)` | N/A (function-like macro) | Construct `double complex` from real & imaginary parts |
| `CMPLXF(x, y)`| N/A (function-like macro) | Construct `float complex` from real & imaginary parts |
| `CMPLXL(x, y)`| N/A (function-like macro) | Construct `long double complex` from real & imaginary parts |

---

## Pragma

### `#pragma STDC CX_LIMITED_RANGE ON/OFF/DEFAULT`

Controls the implementation of complex arithmetic operations for possible performance improvement:

- Recommended: `#pragma STDC CX_LIMITED_RANGE ON`
- Default: OFF
- May cause overflows; use with care.

---

## Types

| Type                    | Description                | Example |
|-------------------------|----------------------------|---------|
| `float _Complex`        | Single precision complex   | `float _Complex z;` |
| `double _Complex`       | Double precision complex   | `double _Complex z;` |
| `long double _Complex`  | Extended precision complex | `long double _Complex z;` |
| `complex`               | Alias for `_Complex`       | `complex double z;` |
| `imaginary`             | Alias for `_Imaginary`     | (rare support) |

---

## Function Reference

All functions have three forms, e.g. `cabsf` (float), `cabs` (double), `cabsl` (long double).

### Basic Operations

| Function  | Description        | Prototype                                 | Example & Output |
|-----------|--------------------|--------------------------------------------|------------------|
| cabs      | Absolute value     | `double cabs(double complex z)`           | See examples     |
| carg      | Phase angle        | `double carg(double complex z)`           | See examples     |
| creal     | Real part          | `double creal(double complex z)`          | See examples     |
| cimag     | Imaginary part     | `double cimag(double complex z)`          | See examples     |
| conj      | Complex conjugate  | `double complex conj(double complex z)`   | See examples     |
| cproj     | Project onto sphere| `double complex cproj(double complex z)`  | See examples     |

### Exponential Functions

| Function  | Description                  | Prototype |
|-----------|------------------------------|-----------|
| cexp      | Complex exponential `e^z`    | `double complex cexp(double complex z)` |
| clog      | Complex natural log `ln(z)`  | `double complex clog(double complex z)` |
| cpow      | Complex power `x^y`          | `double complex cpow(double complex x, y)` |
| csqrt     | Complex square root          | `double complex csqrt(double complex z)` |

### Trigonometric

| Function  | Description             | Prototype |
|-----------|-------------------------|-----------|
| csin      | Complex sine            | `double complex csin(double complex z)` |
| ccos      | Complex cosine          | `double complex ccos(double complex z)` |
| ctan      | Complex tangent         | `double complex ctan(double complex z)` |
| casin     | Complex arc sine        | `double complex casin(double complex z)` |
| cacos     | Complex arc cosine      | `double complex cacos(double complex z)` |
| catan     | Complex arc tangent     | `double complex catan(double complex z)` |

### Hyperbolic and Inverse Hyperbolic

| Function  | Description                     | Prototype |
|-----------|---------------------------------|-----------|
| csinh     | Hyperbolic sine                 | `double complex csinh(double complex z)` |
| ccosh     | Hyperbolic cosine               | `double complex ccosh(double complex z)` |
| ctanh     | Hyperbolic tangent              | `double complex ctanh(double complex z)` |
| casinh    | Arc hyperbolic sine             | `double complex casinh(double complex z)` |
| cacosh    | Arc hyperbolic cosine           | `double complex cacosh(double complex z)` |
| catanh    | Arc hyperbolic tangent          | `double complex catanh(double complex z)` |

---

## Examples

### Example 1: Creating a Complex Number with CMPLX

```c
#include <complex.h>
#include <stdio.h>

int main(void)
{
double real = 1.3, imag = 4.9;
double complex z = CMPLX(real, imag);
printf("z = %.1f+%.1fi\n", creal(z), cimag(z));
return 0;
}
// Output: z = 1.3+4.9i

```

---

### Example 2: Using Macro `I` for Complex Numbers

```c
#include <complex.h>
#include <stdio.h>

int main(void)
{
double complex z = 3.2 + 4.1 * I;
printf("z = %.1f+%.1fi\n", creal(z), cimag(z));
return 0;
}
// Output: z = 3.2+4.1i

```

---

### Example 3: Basic Operations

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z = 3.0 + 4.0*I;
double magnitude = cabs(z);
double real_part = creal(z);
double imag_part = cimag(z);
double phase = carg(z);
double complex conj_z = conj(z);
printf("cabs(3+4i) = %.2f\n", magnitude);
printf("creal(3+4i) = %.2f\n", real_part);
printf("cimag(3+4i) = %.2f\n", imag_part);
printf("carg(3+4i) = %.4f\n", phase);
printf("conj(3+4i) = %.2f%+.2fi\n", creal(conj_z), cimag(conj_z));
return 0;
}
// Output:
// cabs(3+4i) = 5.00
// creal(3+4i) = 3.00
// cimag(3+4i) = 4.00
// carg(3+4i) = 0.9273
// conj(3+4i) = 3.00-4.00i

```

---

### Example 4: Complex Arithmetic

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z1 = 3.0 + 4.0*I;
double complex z2 = 1.0 + 2.0*I;

    double complex sum = z1 + z2;
    double complex product = z1 * z2;
    printf("Sum = %.1f + %.1fi\n", creal(sum), cimag(sum));
    printf("Product = %.1f + %.1fi\n", creal(product), cimag(product));
    return 0;
    }
// Output:
// Sum = 4.0 + 6.0i
// Product = -5.0 + 10.0i

```

---

### Example 5: Exponential and Logarithmic

```c
#include <complex.h>
#include <stdio.h>
#include <math.h>

int main() {
double complex z = 1.0 + M_PI*I;
double complex result = cexp(z);
printf("cexp(1+πi) = %.4f%+.4fi\n", creal(result), cimag(result));

    double complex log_z = clog(z);
    printf("clog(1+πi) = %.4f%+.4fi\n", creal(log_z), cimag(log_z));
    return 0;
    }
// Output:
// cexp(1+πi) = -2.7183+0.0000i
// clog(1+πi) = 1.1447+1.2626i

```

---

### Example 6: Power and Square Root

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex base = 2.0 + 0.0*I;
double complex exponent = 3.0 + 0.0*I;
double complex power = cpow(base, exponent);
printf("cpow(2, 3) = %.1f%+.1fi\n", creal(power), cimag(power));

    double complex z = -1.0 + 0.0*I;
    double complex sqrt_z = csqrt(z);
    printf("csqrt(-1+0i) = %.1f%+.1fi\n", creal(sqrt_z), cimag(sqrt_z));
    return 0;
    }
// Output:
// cpow(2, 3) = 8.0+0.0i
// csqrt(-1+0i) = 0.0+1.0i

```

---

## Type-Generic Math

Including `<tgmath.h>` makes function calls type-generic, choosing the appropriate variant automatically:

```c
#include <tgmath.h>

double complex z = 3.0 + 4.0*I;
double mag = cabs(z); // cabs()
float complex zf = 3.0f + 4.0f*I;
float magf = cabs(zf); // cabsf()
```

---

## Usage Notes

- All angles use radians.
- Functions have three variants for float, double, long double arguments.
- Compile with C99 or later (`gcc file.c -lm`).
- `<complex.h>` does not conflict with C++ `<complex>`, which is a template class.

---

## References

- ISO C99 & C23 Standard Documentation
- cppreference.com, GeeksforGeeks, IBM, Beej.us, Wikibooks
