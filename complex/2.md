# C Standard Library `<complex.h>` — Complete Documentation

## Overview

The `complex.h` header, available since C99, enables **complex number arithmetic** in the C programming language. It provides:

- Complex types (float, double, long double, `_Complex`)
- Construction macros and imaginary unit constants
- Arithmetic, trigonometric, exponential, and hyperbolic functions
- A pragma to control implementation details

---

## Table of Contents

- [Macros](#macros)
- [Pragma](#pragma)
- [Complex Types](#complex-types)
- [Function Reference](#function-reference)
  - [Basic Operations](#basic-operations)
  - [Exponential Functions](#exponential-functions)
  - [Trigonometric Functions](#trigonometric-functions)
  - [Inverse Trigonometric Functions](#inverse-trigonometric-functions)
  - [Hyperbolic Functions](#hyperbolic-functions)
  - [Inverse Hyperbolic Functions](#inverse-hyperbolic-functions)
- [Type-Generic Math](#type-generic-math)
- [Usage Notes](#usage-notes)
- [Example Programs](#example-programs)

---

## Macros

| Macro        | Purpose                                                            | Example Usage                          |
|--------------|--------------------------------------------------------------------|----------------------------------------|
| `complex`    | Expands to `_Complex`, used to declare complex variable            | `complex double z = 3.0 + 4.0*I;`      |
| `imaginary`  | Expands to `_Imaginary` (C99 Annex G only; rare support)           |                                        |
| `I`          | The primary imaginary unit constant                                | `double complex z = 3.0 + 4.0*I;`      |
| `_Complex_I` | Constant of type `float _Complex`, value √-1                       |                                        |
| `_Imaginary_I` | Constant of type `float _Imaginary`, value √-1 (rare support)   |                                        |
| `CMPLX(x, y)`   | Constructs a `double complex` from real/imag parts         | `double complex z = CMPLX(3.0, 4.0);`  |
| `CMPLXF(x, y)`  | Constructs a `float complex` from real/imag parts           | `float complex z = CMPLXF(3.0f, 4.0f);`|
| `CMPLXL(x, y)`  | Constructs a `long double complex` from parts                | `long double complex z = CMPLXL(3.0L, 4.0L);`|

---

## Pragma

### `#pragma STDC CX_LIMITED_RANGE ON/OFF/DEFAULT`

- **Purpose**: Allows using efficient complex arithmetic formulas as specified by C99.
- **Default**: OFF.
- **Caution**: May cause intermediate overflow issues.

**Usage Example:**

```c
#pragma STDC CX_LIMITED_RANGE ON
```

---

## Complex Types

| Type                      | Description                    | Example                  |
|---------------------------|--------------------------------|--------------------------|
| `float _Complex`          | Single precision complex type  | `float _Complex z;`      |
| `double _Complex`         | Double precision complex type  | `double _Complex z;`     |
| `long double _Complex`    | Extended precision complex type| `long double _Complex z;`|

---

## Function Reference

For all functions: available in three forms, e.g. `cabsf` (float), `cabs` (double), `cabsl` (long double).

### Basic Operations

| Function         | Signature                                         | Description                               | Example & Output                     |
|------------------|--------------------------------------------------|-------------------------------------------|--------------------------------------|
| `cabs`           | `double cabs(double complex z)`                  | Magnitude (absolute value): √(re²+im²)    | See [cabs Example](#cabs-example)    |
| `carg`           | `double carg(double complex z)`                  | Phase angle in radians                    | See [carg Example](#carg-example)    |
| `creal`          | `double creal(double complex z)`                 | Real part                                | See [creal Example](#creal-example)  |
| `cimag`          | `double cimag(double complex z)`                 | Imaginary part                           | See [cimag Example](#cimag-example)  |
| `conj`           | `double complex conj(double complex z)`          | Complex conjugate                        | See [conj Example](#conj-example)    |
| `cproj`          | `double complex cproj(double complex z)`         | Project onto Riemann sphere               | See [cproj Example](#cproj-example)  |

### Exponential Functions

| Function         | Signature                                         | Description                       |
|------------------|--------------------------------------------------|-----------------------------------|
| `cexp`           | `double complex cexp(double complex z)`           | Complex exponential               |
| `clog`           | `double complex clog(double complex z)`           | Natural logarithm                 |
| `cpow`           | `double complex cpow(double complex x, y)`        | Power, x raised to complex y      |
| `csqrt`          | `double complex csqrt(double complex z)`          | Complex square root               |

### Trigonometric Functions

| Function         | Signature                                         | Description                       |
|------------------|--------------------------------------------------|-----------------------------------|
| `ccos`           | `double complex ccos(double complex z)`           | Complex cosine                    |
| `csin`           | `double complex csin(double complex z)`           | Complex sine                      |
| `ctan`           | `double complex ctan(double complex z)`           | Complex tangent                   |

### Inverse Trigonometric Functions

| Function         | Signature                                         | Description                       |
|------------------|--------------------------------------------------|-----------------------------------|
| `cacos`          | `double complex cacos(double complex z)`          | Complex arc cosine                |
| `casin`          | `double complex casin(double complex z)`          | Complex arc sine                  |
| `catan`          | `double complex catan(double complex z)`          | Complex arc tangent               |

### Hyperbolic Functions

| Function         | Signature                                         | Description                       |
|------------------|--------------------------------------------------|-----------------------------------|
| `ccosh`          | `double complex ccosh(double complex z)`          | Hyperbolic cosine                 |
| `csinh`          | `double complex csinh(double complex z)`          | Hyperbolic sine                   |
| `ctanh`          | `double complex ctanh(double complex z)`          | Hyperbolic tangent                |

### Inverse Hyperbolic Functions

| Function         | Signature                                         | Description                       |
|------------------|--------------------------------------------------|-----------------------------------|
| `cacosh`         | `double complex cacosh(double complex z)`         | Arc hyperbolic cosine             |
| `casinh`         | `double complex casinh(double complex z)`         | Arc hyperbolic sine               |
| `catanh`         | `double complex catanh(double complex z)`         | Arc hyperbolic tangent            |

---

## Example Programs

### cabs Example

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z = 3.0 + 4.0*I;
double magnitude = cabs(z);
printf("cabs(3+4i) = %.2f\n", magnitude);
return 0;
}
// Output: cabs(3+4i) = 5.00
```

### carg Example

```c
#include <complex.h>
#include <stdio.h>
#include <math.h>

int main() {
double complex z = 1.0 + 1.0*I;
double angle = carg(z);
printf("carg(1+1i) = %.4f radians\n", angle);
printf("carg(1+1i) = %.2f degrees\n", angle * 180.0/M_PI);
return 0;
}
// Output:
// carg(1+1i) = 0.7854 radians
// carg(1+1i) = 45.00 degrees

```

### creal Example

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z = 3.5 - 2.7*I;
double real_part = creal(z);
printf("creal(3.5-2.7i) = %.1f\n", real_part);
return 0;
}
// Output: creal(3.5-2.7i) = 3.5

```

### cimag Example

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z = 3.5 - 2.7*I;
double imag_part = cimag(z);
printf("cimag(3.5-2.7i) = %.1f\n", imag_part);
return 0;
}
// Output: cimag(3.5-2.7i) = -2.7

```

### conj Example

```c
#include <complex.h>
#include <stdio.h>

int main() {
double complex z = 3.0 + 4.0*I;
double complex z_conj = conj(z);
printf("conj(3+4i) = %.1f%+.1fi\n", creal(z_conj), cimag(z_conj));
return 0;
}
// Output: conj(3+4i) = 3.0-4.0i

```

### cproj Example

```c
#include <complex.h>
#include <stdio.h>
#include <math.h>

int main() {
double complex z1 = 1.0 + 2.0*I;
double complex proj1 = cproj(z1);
printf("cproj(1+2i) = %.1f%+.1fi\n", creal(proj1), cimag(proj1));

    double complex z2 = INFINITY + 2.0*I;
    double complex proj2 = cproj(z2);
    printf("cproj(Inf+2i) = %.1f%+.1fi\n", creal(proj2), cimag(proj2));
    return 0;
    }
// Output:
// cproj(1+2i) = 1.0+2.0i
// cproj(Inf+2i) = inf+0.0i

```

### cexp Example

```c
#include <complex.h>
#include <stdio.h>
#include <math.h>

int main() {
double complex z = 1.0 + M_PI*I;
double complex result = cexp(z);
printf("cexp(1+πi) = %.4f%+.4fi\n", creal(result), cimag(result));

    double complex euler = cexp(M_PI*I);
    printf("cexp(πi) = %.4f%+.4fi\n", creal(euler), cimag(euler));
    return 0;
    }
// Output:
// cexp(1+πi) = -2.7183+0.0000i
// cexp(πi) = -1.0000+0.0000i

```

### Complete Example

```c
#include <complex.h>
#include <stdio.h>
#include <math.h>

int main() {
// Create complex numbers
double complex z1 = CMPLX(3.0, 4.0);
double complex z2 = 1.0 + 2.0*I;

    // Basic operations
    printf("z1 = %.1f + %.1fi\n", creal(z1), cimag(z1));
    printf("|z1| = %.2f\n", cabs(z1));
    printf("arg(z1) = %.4f rad\n", carg(z1));
    printf("conj(z1) = %.1f + %.1fi\n", creal(conj(z1)), cimag(conj(z1)));
    
    // Arithmetic
    double complex sum = z1 + z2;
    double complex product = z1 * z2;
    printf("z1 + z2 = %.1f + %.1fi\n", creal(sum), cimag(sum));
    printf("z1 * z2 = %.1f + %.1fi\n", creal(product), cimag(product));
    
    // Complex functions
    double complex exp_result = cexp(z2);
    double complex log_result = clog(z1);
    printf("exp(z2) = %.4f + %.4fi\n", creal(exp_result), cimag(exp_result));
    printf("log(z1) = %.4f + %.4fi\n", creal(log_result), cimag(log_result));
    
    return 0;
    }

```

---

## Type-Generic Math

If you include `<tgmath.h>`, you can use type-generic macros that pick the variant (`float`, `double`, `long double`) for you automatically:

```c
#include <tgmath.h>

double complex z = 3.0 + 4.0*I;
double magnitude = cabs(z);  // Calls cabs()
float complex zf = 3.0f + 4.0f*I;
float magnitude_f = cabs(zf);  // Calls cabsf()

```

---

## Usage Notes

- **Angles** are in radians for all functions.
- **Branch cuts:** Many functions have branch cuts where output is discontinuous; consult standard for details.
- **ISO C99** or later required.

---

## References

- C99 Standard Library Documentation
- cppreference.com, GeeksforGeeks, IBM, Beej.us
